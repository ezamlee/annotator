// Code generated by Prisma (prisma@1.28.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Aggregatedata {
  count: Int!
}

type Aggregatetag {
  count: Int!
}

type Annotation {
  name: String!
  value: String!
  count: Int!
}

input AnnotationCreateInput {
  name: String!
  value: String!
  count: Int!
}

input AnnotationCreateManyInput {
  create: [AnnotationCreateInput!]
}

input AnnotationRestrictedWhereInput {
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  AND: [AnnotationRestrictedWhereInput!]
}

input AnnotationScalarWhereInput {
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  AND: [AnnotationScalarWhereInput!]
  OR: [AnnotationScalarWhereInput!]
  NOT: [AnnotationScalarWhereInput!]
}

input AnnotationUpdateManyDataInput {
  name: String
  value: String
  count: Int
}

input AnnotationUpdateManyInput {
  create: [AnnotationCreateInput!]
  deleteMany: [AnnotationScalarWhereInput!]
  updateMany: [AnnotationUpdateManyWithWhereNestedInput!]
}

input AnnotationUpdateManyWithWhereNestedInput {
  where: AnnotationScalarWhereInput!
  data: AnnotationUpdateManyDataInput!
}

input AnnotationWhereInput {
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  AND: [AnnotationWhereInput!]
}

type BatchPayload {
  count: Long!
}

type data {
  id: ID!
  hash: String!
  text: String
  annotations: [Annotation!]
}

type dataConnection {
  pageInfo: PageInfo!
  edges: [dataEdge]!
  aggregate: Aggregatedata!
}

input dataCreateInput {
  hash: String!
  text: String
  annotations: AnnotationCreateManyInput
}

type dataEdge {
  node: data!
  cursor: String!
}

enum dataOrderByInput {
  id_ASC
  id_DESC
  hash_ASC
  hash_DESC
  text_ASC
  text_DESC
}

type dataPreviousValues {
  id: ID!
  hash: String!
  text: String
}

type dataSubscriptionPayload {
  mutation: MutationType!
  node: data
  updatedFields: [String!]
  previousValues: dataPreviousValues
}

input dataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: dataWhereInput
  AND: [dataSubscriptionWhereInput!]
}

input dataUpdateInput {
  hash: String
  text: String
  annotations: AnnotationUpdateManyInput
}

input dataUpdateManyMutationInput {
  hash: String
  text: String
}

input dataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_lt: String
  hash_lte: String
  hash_gt: String
  hash_gte: String
  hash_contains: String
  hash_not_contains: String
  hash_starts_with: String
  hash_not_starts_with: String
  hash_ends_with: String
  hash_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  annotations_some: AnnotationWhereInput
  annotations_every: AnnotationRestrictedWhereInput
  annotations_none: AnnotationRestrictedWhereInput
  AND: [dataWhereInput!]
}

input dataWhereUniqueInput {
  id: ID
  hash: String
}

scalar Long

type Mutation {
  createdata(data: dataCreateInput!): data!
  updatedata(data: dataUpdateInput!, where: dataWhereUniqueInput!): data
  updateManydatas(data: dataUpdateManyMutationInput!, where: dataWhereInput): BatchPayload!
  upsertdata(where: dataWhereUniqueInput!, create: dataCreateInput!, update: dataUpdateInput!): data!
  deletedata(where: dataWhereUniqueInput!): data
  deleteManydatas(where: dataWhereInput): BatchPayload!
  createtag(data: tagCreateInput!): tag!
  updatetag(data: tagUpdateInput!, where: tagWhereUniqueInput!): tag
  updateManytags(data: tagUpdateManyMutationInput!, where: tagWhereInput): BatchPayload!
  upserttag(where: tagWhereUniqueInput!, create: tagCreateInput!, update: tagUpdateInput!): tag!
  deletetag(where: tagWhereUniqueInput!): tag
  deleteManytags(where: tagWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  data(where: dataWhereUniqueInput!): data
  datas(where: dataWhereInput, orderBy: dataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [data]!
  datasConnection(where: dataWhereInput, orderBy: dataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): dataConnection!
  tag(where: tagWhereUniqueInput!): tag
  tags(where: tagWhereInput, orderBy: tagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [tag]!
  tagsConnection(where: tagWhereInput, orderBy: tagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): tagConnection!
  node(id: ID!): Node
}

type Subscription {
  data(where: dataSubscriptionWhereInput): dataSubscriptionPayload
  tag(where: tagSubscriptionWhereInput): tagSubscriptionPayload
}

type tag {
  id: ID!
  type: String!
  name: String!
  values: [String!]!
}

type tagConnection {
  pageInfo: PageInfo!
  edges: [tagEdge]!
  aggregate: Aggregatetag!
}

input tagCreateInput {
  type: String!
  name: String!
  values: tagCreatevaluesInput
}

input tagCreatevaluesInput {
  set: [String!]
}

type tagEdge {
  node: tag!
  cursor: String!
}

enum tagOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
}

type tagPreviousValues {
  id: ID!
  type: String!
  name: String!
  values: [String!]!
}

type tagSubscriptionPayload {
  mutation: MutationType!
  node: tag
  updatedFields: [String!]
  previousValues: tagPreviousValues
}

input tagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: tagWhereInput
  AND: [tagSubscriptionWhereInput!]
}

input tagUpdateInput {
  type: String
  name: String
  values: tagUpdatevaluesInput
}

input tagUpdateManyMutationInput {
  type: String
  name: String
  values: tagUpdatevaluesInput
}

input tagUpdatevaluesInput {
  set: [String!]
}

input tagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [tagWhereInput!]
}

input tagWhereUniqueInput {
  id: ID
  name: String
}
`